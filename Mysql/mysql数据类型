MySQL数据类型：整数类型、实数类型、字符串类型、枚举、时间和日期、列属性
	整数类型
		TINYINT、SMALLINT、MEDIUMINT、INT、BINGINT
		tinyint无符号 255   有符号 -128 127
		属性：UNSIGNED 非负
		int(3) 在mysql中指定zerofill(位数不够时 用零填充的机制)。相反的未指定是不会进行零填充的


	实数类型
		FLOAT、DOUBLE、DECIMAL
		注意：decimal可以存储比BIGINT还大的整数；可以用于存储精确的小数
		FLOAT与DOUBLE类型支持使用标准的浮点进行近似计算


	字符串类型
		VARCHAR、CHAR、TEXT、BLOB
		VARCHAR类型存储可变长字符串，比定长更加节省空间	(varchar实际存储如果超过了定义的长度 则会将字符串在定长处截断)
		VARCHAR使用1或2个额外字节记录字符串的长度，列长度小于255字节，使用1字节表示，否则用2个	

		CHAR是定长，根据定义的字符串长度分配足够的空间
		CHAR会根据所需要采用空格进行填充以方便比较
		CHAR适合存储很短的字符串，或者所有值都接近同一个长度
		CHAR长度，超出设定的长度，会被截断

		对于经常变更的数据，CHAR比VARCHAR更好，CHAR不容易产生碎片
		对于非常短的列，CHAR比VARCHAR在存储空间上更有效率
		只分配真正需要的空间，更长的列只会消耗更多的内存

		尽量避免使用BLOB与TEXT类型，查询会使用临时表，导致严重的性能开销


	枚举
		有时可以使用枚举代替常用的字符串类型
		把不重复的集合存储成一个预定义的集合
		非常紧凑，把列表值压缩到一个或两个字节
		内部存储的是整数

		尽量避免使用数字作为ENUM枚举的常量，易混乱
		排序是按照内部存储的整数进行排序
		枚举表会使表大小大大减少


	时间和日期类型
		尽量使用TIMESTAMP,比DATETIME空间效率高
		用证书保存时间戳的格式通常不方便处理
		如果需要存储微秒，可以使用bigint存储


	列属性
		auto_increment
		default
		not null
		zerofill




==Mysql基础操作
	常见操作
	连接和关闭
	其他：\G 将打印的结果垂直化的显示
		\c 取消当前mysql的命令
		\q 退出mysql
		\s 显示mysql的服务状态
		\h 帮助信息
		\d 执行符 改分号



=== MySQL数据表引擎
	InnoDB表引擎
		默认事务型引擎，最重要最广泛的存储引擎，性能非常优秀
		数据存储在共享表空间，可以通过配置分开(索引与文件都在一个文件存储 所以快)
		对主键查询的性能高于其他类型的存储引擎
		内部做了很多的优化，从磁盘读取数据时自动在内存构建hash索引，插入数据时自动构建插入缓冲区
		通过一些机制和工具支持真正的热备份
		支持崩溃后的安全恢复
		支持行级锁
		支持外键


	MyISAM
		mysql5.1版本之前，MyISAM是默认的存储引擎
		拥有全文检索、压缩、空间函数
		不支持事物和行级锁，不支持崩溃后的安全恢复(支持表锁)
		表存储在两个文件，MYD和MYI(数据和索引)
		设计简单 某些场景下性能很好


	其他引擎 Archive、Blackhole、CVS、Memory
	优先选择Innodb



==MySQL锁机制
	基础概念
		表锁是日常开当中常见的问题，因此也是面试当中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题
		锁分为共享锁(读锁)和排他锁(写锁)

		共享锁(读锁)：共享的，不堵塞，多个用户可以同时读一个资源，互不干扰
		排他锁(写锁)：排他的，一个写锁会阻塞其他的写锁和读锁，这样可以只允许一个人进行写入，防止其他用户读取正在写入的资源

		锁粒度：
			表锁，系统性能开销最小，会锁定整张表，MyISAM使用表锁
			行锁，最大程度地支持并发处理，但是也会带来了最大的锁开销，Innodb实现行级锁



==MySQL事物处理
	事务处理
		MySQL提供事物处理的引擎 Innodb
		服务器层不管理事物，由下层的引擎实现，所以同一个事务中，使用多种存储引擎不靠谱
		在非事物的表是哪个执行事物操作MySQL不会发出提醒，也不会报错



==MySQL存储过程
	为以后的使用而保存的一条或多条mysql语句集合
	存储过程就是有业务逻辑和流程的集合
	可以在存储过程中创建表，更新表，删除等等

	使用场景
		通过把处理封装在容易使用的单元中，简化复杂的操作
		保证数据的一致性
		简化对变动的管理



==MySQL触发器
	触发器
		是提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程

		使用场景：
			可以通过数据库中的相关表实现级联更改（比如改一张表自动去改另外的一张表）
			实时监控某张表中的某个字段的更改而需要作出相应的处理（自动处理）
			某些业务编号的生成

			滥用会造成数据库及应用程序的维护困难




Innodb与MyISAM的区别
	Innodb支持事物，Innodb支持行锁，Innodb存储在共享空间，Innodb支持崩溃后的安全修复，
		而导致行锁变为表锁的情况之一就是：SQL的更新（update）或者删除（delete）语句中未使用到索引，
		导致在InnoDB在对数据进行相应操作的时候必须把整个表锁起来进行检索（表锁）。而如果使用了索引的话，
		InnoDB只会通过索引条件检索数据，而只锁住索引对应的行（行锁）。


	MyISAM不支持事物，MyISAM支持表锁，MyISAM不使用共享表空间，MyISAM不支持崩溃后的安全修复，












脏读：就是指一个事物 正在进行 且改了数据但是没有提交 这时候另一个事物也访问这个数据 然后使用了这个数据

不可重复读：一个事物内多次读同一个数据，在这个事物没有结束时，另外一个事物也访问了该同一数据。
	那么在第一个事物中的两次读数据之间，由于第二个事物的修改 第一个事物的两次读的结果是不一样的 因此被称为不可重复读

幻读：是指当事物不是独立执行时发生的一种现象，例如当一个事物改变了表中的所有数据行 
	但此时又有一个事物插入了一条新的数据 以后就会发现操作第一个事物修改之后 还有没有被修改的数据 就好像发生了幻读一样






































